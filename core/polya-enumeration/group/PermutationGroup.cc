#include "core/polya-enumeration/group/PermutationGroup.hh"

#include "core/util/Exception.hh"

#include <functional>
#include <queue>
#include <range/v3/all.hpp>
#include <set>
#include <utility>

namespace polya
{
namespace views = ranges::views;
using Degree = Permutation::Degree;
using Element = Permutation::Element;
using Cycle = Permutation::Cycle;

namespace
{
// Finds the subgroup generated by a set of elements
auto generateSubgroup(Degree aDegree, const PermutationGroup::Generators& aGenerators)
    -> PermutationGroup::Elements
{
    ensure(
        ranges::all_of(
            aGenerators.get() | views::transform(&Permutation::degree),
            std::bind_front(std::equal_to{}, aDegree)
        ),
        "Not all generators have degree {}", aDegree.get()
    );
    const auto myIdentity = Permutation(aDegree);
    const auto myGenerators =
        views::concat(
            aGenerators.get(), aGenerators.get() | views::transform(&Permutation::inverse)
        )
        | ranges::to<std::vector<Permutation>>();

    auto myElements = std::set<Permutation>{myIdentity}; // identity is in every subgroup

    auto mySearchFrontier = std::queue<Permutation>{};
    mySearchFrontier.push(myIdentity);
    while (not mySearchFrontier.empty())
    {
        const auto myFrontierElement = mySearchFrontier.front();
        mySearchFrontier.pop();
        for (const auto& myNewElement :
             myGenerators
                 | views::transform([&myFrontierElement](const auto& myGenerator)
                                    { return myFrontierElement * myGenerator; })
                 | views::filter([&myElements](const auto& myElement)
                                 { return not myElements.contains(myElement); }))
        {
            myElements.insert(myNewElement);
            mySearchFrontier.push(myNewElement);
        }
    }
    return PermutationGroup::Elements{myElements | ranges::to<std::vector<Permutation>>()};
}
} // namespace

PermutationGroup::PermutationGroup(std::string_view aName, Elements anElements)
    : theName{aName}, theElements{std::move(anElements)}
{
    ensure(not theElements.get().empty(), "Group cannot be empty");
    ranges::sort(theElements.get());
}

PermutationGroup::PermutationGroup(
    std::string_view aName, Degree aDegree, const Generators& aGenerators
)
    : theName{aName}, theElements{generateSubgroup(aDegree, aGenerators)}
{
}

auto PermutationGroup::name() const -> std::string_view
{
    return theName;
}

auto PermutationGroup::order() const -> Order
{
    return Order{theElements.get().size()};
}

auto PermutationGroup::degree() const -> Degree
{
    return theElements.get().front().degree();
}

auto PermutationGroup::elements() const -> const Elements&
{
    return theElements;
}

auto PermutationGroup::contains(const Permutation& aPermutation) const -> bool
{
    return ranges::any_of(theElements.get(), std::bind_front(std::equal_to{}, aPermutation));
}

auto PermutationGroup::toString() const -> std::string
{
    auto myElements = theElements.get() | views::transform(&Permutation::toString)
                      | views::join(std::string_view{"\n\t"}) | ranges::to<std::string>();
    return theName + "(order: " + std::to_string(order().get())
           + ", degree: " + std::to_string(degree().get()) + ") {\n\t" + myElements + "\n}";
}

auto operator<<(std::ostream& aStream, const PermutationGroup& aGroup) -> std::ostream&
{
    return aStream << aGroup.toString();
}

auto PermutationGroup::isValidGroup() const -> bool
{
    return hasClosure() and hasIdentity() and hasInverse();
}

auto PermutationGroup::hasClosure() const -> bool
{
    return ranges::all_of(
        views::cartesian_product(theElements.get(), theElements.get()),
        [&](const auto& aPair)
        {
            const auto& [aFirstElement, aSecondElement] = aPair;
            return contains(aFirstElement * aSecondElement);
        }
    );
}

auto PermutationGroup::hasIdentity() const -> bool
{
    return contains(Permutation(degree()));
}

auto PermutationGroup::hasInverse() const -> bool
{
    return ranges::all_of(
        theElements.get(),
        [&](const auto& anElement)
        {
            return ranges::any_of(
                theElements.get(), [&](const auto& aPotentialInverse)
                { return (aPotentialInverse * anElement).isIdentity(); }
            );
        }
    );
}

namespace groups
{
// C_n: cyclic group of order n
// generated by a single rotation
auto cyclic(Degree aDegree) -> PermutationGroup
{
    ensure(aDegree.get() > 0, "Expected a non zero degree");
    return PermutationGroup{
        "C_" + std::to_string(aDegree.get()), aDegree,
        PermutationGroup::Generators{std::vector{permutations::rotation(aDegree)}}};
}

// D_2n: dihedral group of order 2n
// generated by a rotation and reflection
auto dihedral(Degree aDegree) -> PermutationGroup
{
    ensure(aDegree.get() > 0, "Expected a non zero degree");
    return PermutationGroup{
        "D_" + std::to_string(aDegree.get()), aDegree,
        PermutationGroup::Generators{
            std::vector{permutations::rotation(aDegree), permutations::reflection(aDegree)}}};
}

// S_n: symmetric group of order n!
// generated by a rotation and a single transposition
auto symmetric(Degree aDegree) -> PermutationGroup
{
    ensure(aDegree.get() > 0, "Expected a non zero degree");
    // No transpositions on {0}
    if (aDegree.get() == 1)
    {
        return trivial(aDegree);
    }
    return PermutationGroup{
        "S_" + std::to_string(aDegree.get()), aDegree,
        PermutationGroup::Generators{std::vector{
            permutations::transposition(aDegree, Element{0}, Element{1}),
            permutations::rotation(aDegree)}}};
}

// Trivial group containing only the identity
auto trivial(Degree aDegree) -> PermutationGroup
{
    return PermutationGroup{
        "Trivial_" + std::to_string(aDegree.get()),
        PermutationGroup::Elements{std::vector{Permutation{aDegree}}}};
}

// Tetrahedron rotational symmetry group (A_4)
// generated by a 120 degree vertex-to-face rotation (123)
// and a 180 degree edge-to-edge rotation (12)(34)
auto tetrahedron() -> PermutationGroup
{
    return PermutationGroup{
        "Tetrahedron", Degree{4},
        PermutationGroup::Generators{std::vector{
            Permutation{Degree{4}, {Cycle{{Element{0}, Element{1}, Element{2}}}}},
            Permutation{
                Degree{4}, {Cycle{{Element{0}, Element{1}}}, Cycle{{Element{2}, Element{3}}}}}}}};
}

// Cube rotational symmetry group
// generated by 90 degree rotations around each axis.
auto cube() -> PermutationGroup
{
    return PermutationGroup{
        "Cube", Degree{6},
        PermutationGroup::Generators{std::vector{
            Permutation{Degree{6}, {Cycle{{Element{1}, Element{2}, Element{3}, Element{4}}}}},
            Permutation{Degree{6}, {Cycle{{Element{0}, Element{1}, Element{5}, Element{3}}}}},
            Permutation{Degree{6}, {Cycle{{Element{0}, Element{2}, Element{5}, Element{4}}}}}}}};
}
} // namespace groups
} // namespace polya
